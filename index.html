<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>REAL-TIME PHYSICS · GEOMETRY MONITOR</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  html, body {
    margin: 0; padding: 0;
    background: #0a0a0a;
    overflow: hidden;
    height: 100%;
    font-family: 'Courier New', monospace;
    color: #0ff;
  }
  #container {
    position: absolute;
    inset: 60px;
    border: 1px solid #1a1a2e;
    box-sizing: border-box;
    overflow: hidden;
    background: #000;
  }
  canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
  #hud {
    position: absolute;
    top: 20px; left: 20px;
    font-size: 12px;
    opacity: 0.7;
    pointer-events: none;
    z-index: 10;
  }
  #data {
    position: absolute;
    top: 90px; left: 20px;
    font-size: 10px;
    opacity: 0.55;
    pointer-events: none;
    max-width: 320px;
    line-height: 1.35;
    z-index: 10;
  }
  #data span.val { color: #fff; }
</style>
</head>
<body>

<div id="hud">REAL-TIME PHYSICS · GEOMETRY MONITOR</div>
<div id="data">Завантаження...</div>

<div id="container">
  <canvas id="c"></canvas>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const dataDiv = document.getElementById('data');

function resize() {
  const container = document.getElementById('container');
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
}
window.addEventListener('resize', resize);
resize();

// Масштабування вмісту
const SCALE = 0.65;
const OFFSET_X = canvas.width * (1 - SCALE) / 2;
const OFFSET_Y = canvas.height * (1 - SCALE) / 2;

// Зірки
const stars = [];
for (let i = 0; i < 300; i++) {
  stars.push({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    size: Math.random() * 1.2 + 0.3,
    speed: Math.random() * 0.04 + 0.01
  });
}

// Дані та API
let realData = {
  seismic: 0.5, magnetic: 0.5, atmosphere_wind: 0.5,
  atmosphere_pressure: 0.5, atmosphere_temp: 0.5,
  ocean: 0.5, solar_radiation: 0.5, solar_wind: 0.5,
  precipitation: 0.5, chaos: 0.5
};
let dataHistory = {};
Object.keys(realData).forEach(k => dataHistory[k] = []);

const LAT = 50.45, LON = 30.52;
const API = {
  weather: `https://api.open-meteo.com/v1/forecast?latitude=${LAT}&longitude=${LON}&current=temperature_2m,pressure_msl,wind_speed_10m,precipitation`,
  ocean: `https://api.open-meteo.com/v1/marine?latitude=${LAT}&longitude=${LON}&current=wave_height`,
  seismic: 'https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&starttime=now-1h&minmagnitude=2.5',
  magnetic: 'https://services.swpc.noaa.gov/products/noaa-planetary-k-index.json',
  solar_wind: 'https://services.swpc.noaa.gov/products/solar-wind/plasma-7-day.json',
  radiation: `https://api.open-meteo.com/v1/forecast?latitude=${LAT}&longitude=${LON}&current=shortwave_radiation`
};

async function updateRealData() {
  try {
    const w = await fetch(API.weather).then(r => r.json()).then(d => d.current);
    realData.atmosphere_temp = Math.min(1, (w.temperature_2m + 40) / 80);
    realData.atmosphere_pressure = Math.min(1, Math.abs(w.pressure_msl - 1013) / 50);
    realData.atmosphere_wind = Math.min(1, w.wind_speed_10m / 50);
    realData.precipitation = Math.min(1, w.precipitation / 10);

    realData.ocean = await fetch(API.ocean).then(r => r.json()).then(d => Math.min(1, d.current.wave_height / 5)).catch(() => 0.5);
    realData.solar_radiation = await fetch(API.radiation).then(r => r.json()).then(d => Math.min(1, d.current.shortwave_radiation / 1000)).catch(() => 0.5);
    realData.seismic = await fetch(API.seismic).then(r => r.json()).then(d => Math.min(1, d.features.length / 20)).catch(() => 0.5);
    realData.magnetic = await fetch(API.magnetic).then(r => r.json()).then(d => parseFloat(d.at(-1)[1]) / 9).catch(() => 0.5);
    realData.solar_wind = await fetch(API.solar_wind).then(r => r.json()).then(d => Math.min(1, (parseFloat(d.at(-1)[3]) - 300) / 700)).catch(() => 0.5);

    Object.keys(realData).forEach(k => {
      if (k !== 'chaos') {
        dataHistory[k].push(realData[k]);
        if (dataHistory[k].length > 60) dataHistory[k].shift();
      }
    });
    let vars = [];
    for (let k in dataHistory) {
      const h = dataHistory[k];
      if (h.length < 3) continue;
      const m = h.reduce((a, b) => a + b, 0) / h.length;
      const v = h.reduce((a, b) => a + (b - m) ** 2, 0) / h.length;
      vars.push(Math.sqrt(v));
    }
    realData.chaos = vars.length ? Math.min(1, (vars.reduce((a, b) => a + b, 0) / vars.length) * 10) : 0.5;

    dataDiv.innerHTML = `
      magnetic ...... <span class="val">${(realData.magnetic * 9).toFixed(1)}</span><br>
      solar_wind .... <span class="val">${Math.round(300 + realData.solar_wind * 700)}</span> km/s<br>
      seismic ....... <span class="val">${Math.round(realData.seismic * 20)}</span> eq/h<br>
      wind .......... <span class="val">${Math.round(realData.atmosphere_wind * 50)}</span> km/h<br>
      pressure dev .. <span class="val">${Math.round(realData.atmosphere_pressure * 50)}</span> hPa<br>
      temp .......... <span class="val">${((realData.atmosphere_temp * 80) - 40).toFixed(1)}</span> °C<br>
      ocean ......... <span class="val">${(realData.ocean * 5).toFixed(1)}</span> m<br>
      radiation ..... <span class="val">${Math.round(realData.solar_radiation * 1000)}</span> W/m²<br>
      precip ........ <span class="val">${(realData.precipitation * 10).toFixed(1)}</span> mm<br>
      CHAOS ......... <span class="val">${realData.chaos.toFixed(3)}</span>
    `;
  } catch (e) {
    dataDiv.innerHTML = "Дані недоступні";
  }
}
updateRealData();
setInterval(updateRealData, 60000);

// ─── Частинки для кожного параметра ───────────────────────
class Particle {
  constructor(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.life = 1;
    this.vx = (Math.random() - 0.5) * 1.5;
    this.vy = (Math.random() - 0.5) * 1.5;
    this.color = getColor(type);
    this.size = 2;
  }
  update(cx, cy, d) {
    this.life -= 0.008 + d.chaos * 0.005;  // chaos прискорює зникнення

    const dx = cx - this.x;
    const dy = cy - this.y;
    const dist = Math.hypot(dx, dy) || 1;

    const force = d[this.type] * 0.03;

    switch (this.type) {
      case 'magnetic':
        this.vx += dx / dist * force * 2;    // притягує до центру
        this.vy += dy / dist * force * 2;
        break;
      case 'solar_wind':
        this.vx += force * 4;                 // сильний рух праворуч
        break;
      case 'seismic':
        this.vx += (Math.random() - 0.5) * force * 6;  // хаотичний розліт
        this.vy += (Math.random() - 0.5) * force * 6;
        break;
      case 'atmosphere_wind':
        this.vx += force * 3 * Math.sin(t * 3);  // коливання
        break;
      case 'atmosphere_pressure':
        this.size = 2 + force * 8;            // пульсує розмір
        break;
      case 'atmosphere_temp':
        this.vy -= force * 2.5;               // піднімається вгору при теплі
        break;
      case 'ocean':
        this.vy += Math.sin(t * 2 + this.x * 0.01) * force * 2;  // хвилі
        break;
      case 'solar_radiation':
        this.vx += (Math.random() - 0.5) * force * 5;
        this.vy += (Math.random() - 0.5) * force * 5;  // випадковий розліт
        break;
      case 'precipitation':
        this.vy += force * 5;                 // падають вниз
        break;
      case 'chaos':
        this.vx += (Math.random() - 0.5) * force * 8;
        this.vy += (Math.random() - 0.5) * force * 8;  // повний хаос
        break;
    }

    this.x += this.vx;
    this.y += this.vy;
  }
  draw() {
    ctx.globalAlpha = this.life;
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
  }
}

const particles = [];

function getColor(type) {
  const map = {
    magnetic: '#00ffff',
    solar_wind: '#ffaa00',
    seismic: '#ff4444',
    atmosphere_wind: '#88ff88',
    atmosphere_pressure: '#ff88ff',
    atmosphere_temp: '#ffbb66',
    ocean: '#4488ff',
    solar_radiation: '#ffff88',
    precipitation: '#88ccff',
    chaos: '#ff00ff'
  };
  return map[type] || '#cccccc';
}

// ─── Основний цикл ───────────────────────
let t = 0;
function loop() {
  t += 0.016;

  ctx.fillStyle = 'rgba(0,0,0,0.07)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  ctx.translate(OFFSET_X, OFFSET_Y);
  ctx.scale(SCALE, SCALE);

  const cx = canvas.width / 2 / SCALE;
  const cy = canvas.height / 2 / SCALE;
  const d = realData;

  // Генерація частинок — чим вище значення, тим більше частинок
  Object.keys(d).forEach(key => {
    if (key === 'chaos') return;
    const chance = d[key] * 0.08 + 0.005;  // базова ймовірність + залежність від значення
    if (Math.random() < chance) {
      const angle = Math.random() * Math.PI * 2;
      const dist = 60 + Math.random() * 180;
      const px = cx + Math.cos(angle) * dist;
      const py = cy + Math.sin(angle) * dist;
      particles.push(new Particle(px, py, key));
    }
  });

  // Оновлення та малювання
  particles.forEach(p => {
    p.update(cx, cy, d);
    p.draw();
  });

  // Видалення мертвих частинок
  for (let i = particles.length - 1; i >= 0; i--) {
    if (particles[i].life <= 0) {
      particles.splice(i, 1);
    }
  }

  // Зірки
  ctx.fillStyle = '#0ff';
  stars.forEach(s => {
    s.y += s.speed * (1 + d.solar_wind * 3);
    if (s.y > canvas.height / SCALE + 30) s.y -= canvas.height / SCALE + 60;
    ctx.globalAlpha = 0.4 + d.solar_wind * 0.35;
    ctx.fillRect(s.x, s.y, s.size, s.size);
  });
  ctx.globalAlpha = 1;

  // ─── решта твоєї геометрії ───
  // 1. Концентричні кола (magnetic)
  for (let i = 1; i <= 5; i++) {
    const r = 40 + i * 25 + Math.sin(t * 1.3 + i * 1.6) * (5 + d.magnetic * 20);
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(0,180,255,${0.15 + d.magnetic * 0.3})`;
    ctx.lineWidth = (0.8 + d.chaos * 1.2) / SCALE;
    ctx.stroke();
  }

  // 2. Сейсмічні хвилі
  if (d.seismic > 0.25) {
    const rings = Math.floor(d.seismic * 6) + 1;
    for (let i = 0; i < rings; i++) {
      const r = (t * 50 + i * 70) % 450;
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(255,50,50,${0.4 * d.seismic * (1 - r / 450)})`;
      ctx.lineWidth = 1.3 / SCALE;
      ctx.stroke();
    }
  }

  // (тут можна додати решту твоїх геометричних елементів — вітер, океан, опади, температура, радіація — як було раніше)

  ctx.restore();

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
